package com.school.management.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Entity representing a fee receipt generated for student fee payment.
 *
 * Database Table: fee_receipts
 *
 * This entity stores the complete details of a fee payment transaction including
 * receipt number, payment details, fee breakdown, and link to fee journal entries.
 *
 * Business Rules:
 * - Receipt number must be unique (Format: REC-YYYY-NNNNN)
 * - Fee breakdown is stored as JSON
 * - Payment date cannot be future date
 * - Links to multiple fee journal entries (for multiple months)
 *
 * @author School Management Team
 */
@Entity
@Table(name = "fee_receipts", indexes = {
    @Index(name = "idx_receipt_number", columnList = "receipt_number", unique = true),
    @Index(name = "idx_student_id", columnList = "student_id"),
    @Index(name = "idx_payment_date", columnList = "payment_date")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FeeReceipt {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "receipt_number", nullable = false, unique = true, length = 50)
    @NotBlank(message = "Receipt number is required")
    private String receiptNumber;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", nullable = false)
    @NotNull(message = "Student is required")
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Student student;

    @Column(name = "amount", nullable = false, precision = 10, scale = 2)
    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Amount must be greater than 0")
    private BigDecimal amount;

    @Column(name = "payment_date", nullable = false)
    @NotNull(message = "Payment date is required")
    @PastOrPresent(message = "Payment date cannot be in the future")
    private LocalDate paymentDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 20)
    @NotNull(message = "Payment method is required")
    private PaymentMethod paymentMethod;

    @Column(name = "transaction_id", length = 100)
    private String transactionId;

    @Column(name = "cheque_number", length = 50)
    private String chequeNumber;

    @Column(name = "bank_name", length = 100)
    private String bankName;

    @Column(name = "months_paid", nullable = false, length = 200)
    @NotBlank(message = "Months paid is required")
    private String monthsPaid; // "January, February"

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "fee_breakdown", columnDefinition = "jsonb")
    @Builder.Default
    private Map<String, Object> feeBreakdown = new HashMap<>();

    @Column(name = "remarks", length = 500)
    private String remarks;

    @Column(name = "generated_by", nullable = false, length = 100)
    @NotBlank(message = "Generated by is required")
    @Builder.Default
    private String generatedBy = "ADMIN";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // Bidirectional relationship with FeeJournal
    @OneToMany(mappedBy = "receipt", fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<FeeJournal> journalEntries;

    /**
     * Get formatted receipt number
     * @return Receipt number with proper formatting
     */
    @Transient
    public String getFormattedReceiptNumber() {
        return receiptNumber != null ? receiptNumber : "N/A";
    }

    /**
     * Get receipt year from receipt number
     * @return Year extracted from receipt number
     */
    @Transient
    public String getReceiptYear() {
        if (receiptNumber != null && receiptNumber.contains("-")) {
            String[] parts = receiptNumber.split("-");
            if (parts.length >= 2) {
                return parts[1];
            }
        }
        return String.valueOf(LocalDate.now().getYear());
    }

    /**
     * Get total amount from fee breakdown
     * @return Total amount from breakdown or amount field
     */
    @Transient
    public BigDecimal getTotalFromBreakdown() {
        if (feeBreakdown != null && feeBreakdown.containsKey("total")) {
            Object totalObj = feeBreakdown.get("total");
            if (totalObj instanceof Number) {
                return BigDecimal.valueOf(((Number) totalObj).doubleValue());
            }
        }
        return amount;
    }

    /**
     * Get months paid as array
     * @return Array of month names
     */
    @Transient
    public String[] getMonthsArray() {
        if (monthsPaid == null || monthsPaid.isBlank()) {
            return new String[0];
        }
        return monthsPaid.split(",\\s*");
    }

    /**
     * Check if receipt is for online payment
     * @return true if payment method is ONLINE or CARD
     */
    @Transient
    public boolean isOnlinePayment() {
        return PaymentMethod.ONLINE.equals(paymentMethod) ||
               PaymentMethod.CARD.equals(paymentMethod);
    }
}
